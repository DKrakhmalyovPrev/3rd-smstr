Задание 9: Дан язык, заданный регулярным выражением и слово из алфавита {a,b,c}.Проверить, содержит ли язык данное слово. 

Идея алгоритма: разбор РВ и построение недетерменированного конечного автомата с эпсилон-переходами. 
Рекурсивное прохождение слова по автомату(куда может -- туда идёт) до завершения слова либо состояний автомата.

Пошаговое описание алгоритма:
1)Чтение РВ и входного слова.
2)Парсинг РВ (ф-я ParseSmart()) последовательным прохождением по символам:
   -Встречая символ алфавита -- строит новое состояние автомата, в которое переходит из всех состояний "предыдущего уровня"
   -Встречая знак "." -- объединяет последние два состояния в переход по строке, а не по одному символу
   (если объединяются два символа, а не конструкции)
   -Встречая знак "+" -- перемещает последние два состояния на один уровень, давая возможность пойти по любому из них.
   -Встречая знак "*" -- строит эпсилон-переход в состояние "за скобками" (то есть на кол-во состояний, равному кол-ву конкатенаций) и обратно(для пропуска состояния)
3)Проход слова по РВ(ф-я JustDoIt())
    -Функция работает рекурсивно, проходя по уровням нашего НДКА. Идёт по состояниям и если может двинуться дальше -- вызывает себя рекурсивно
    от следующего символа и следующего состояния. Если достигла одновременно конца НДКА и слова -- возвращает единицу. Если какой-либо рекурсивный
    вызов вернул единицу -- возвращает её дальше по дереву рекурсии.
4)Получив 1 или 0 в корне рекурсии, можем сделать вывод о том, достигалось ли конечное состояние когда-либо. Получаем ответ.

Проблемы с алгоритмом:
1) При неверном задании РВ:
  -При недопустимом символе программа выдаст ошибку
  -При допуске цикла из эпсилон-переходов, например (..)** или (а+1)* программа зацикливается (построить слово по такому НДКА невозможно 
  даже алгоритмически, так что стоит упрощать ввод до эквивалентных (..)* и а*, что некоторым примитивным образом реализовано в программе.
  Сложные функции, допускающие э-п, будут крашить программу по переполнению стека вызовов.
   
